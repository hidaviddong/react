{"version":3,"file":"react-dom.development.js","sources":["../../../../packages/react-dom/src/ReactDOMSharedInternals.js","../../../../packages/shared/ReactVersion.js","../../../../packages/shared/ReactFeatureFlags.js","../../../../packages/react-dom-bindings/src/client/HTMLNodeType.js","../../../../packages/react-dom-bindings/src/client/ReactDOMContainer.js","../../../../packages/shared/ReactSymbols.js","../../../../packages/shared/CheckStringCoercion.js","../../../../packages/react-reconciler/src/ReactPortal.js","../../../../packages/react-reconciler/src/ReactFiberLane.js","../../../../packages/react-reconciler/src/ReactEventPriorities.js","../../../../packages/shared/ReactSharedInternals.js","../../../../packages/react-dom/src/shared/ReactDOMFlushSync.js","../../../../packages/react-dom-bindings/src/shared/crossOriginStrings.js","../../../../packages/react-dom/src/shared/ReactDOMFloat.js","../../../../packages/react-dom-bindings/src/shared/ReactDOMFormActions.js","../../../../packages/react-dom/src/shared/ReactDOM.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {EventPriority} from 'react-reconciler/src/ReactEventPriorities';\nimport type {HostDispatcher} from './shared/ReactDOMTypes';\n\n// This should line up with NoEventPriority from react-reconciler/src/ReactEventPriorities\n// but we can't depend on the react-reconciler from this isomorphic code.\nexport const NoEventPriority: EventPriority = (0: any);\n\ntype ReactDOMInternals = {\n  d /* ReactDOMCurrentDispatcher */: HostDispatcher,\n  p /* currentUpdatePriority */: EventPriority,\n  findDOMNode:\n    | null\n    | ((\n        componentOrElement: React$Component<any, any>,\n      ) => null | Element | Text),\n};\n\nfunction noop() {}\n\nfunction requestFormReset(element: HTMLFormElement) {\n  throw new Error(\n    'Invalid form element. requestFormReset must be passed a form that was ' +\n      'rendered by React.',\n  );\n}\n\nconst DefaultDispatcher: HostDispatcher = {\n  f /* flushSyncWork */: noop,\n  r /* requestFormReset */: requestFormReset,\n  D /* prefetchDNS */: noop,\n  C /* preconnect */: noop,\n  L /* preload */: noop,\n  m /* preloadModule */: noop,\n  X /* preinitScript */: noop,\n  S /* preinitStyle */: noop,\n  M /* preinitModuleScript */: noop,\n};\n\nconst Internals: ReactDOMInternals = {\n  d /* ReactDOMCurrentDispatcher */: DefaultDispatcher,\n  p /* currentUpdatePriority */: NoEventPriority,\n  findDOMNode: null,\n};\n\nexport default Internals;\n","export default '19.1.0-canary-bd8cd8af-20250717';\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n */\n\n// -----------------------------------------------------------------------------\n// Land or remove (zero effort)\n//\n// Flags that can likely be deleted or landed without consequences\n// -----------------------------------------------------------------------------\n\n// None\n\n// -----------------------------------------------------------------------------\n// Killswitch\n//\n// Flags that exist solely to turn off a change in case it causes a regression\n// when it rolls out to prod. We should remove these as soon as possible.\n// -----------------------------------------------------------------------------\n\nexport const enableHydrationLaneScheduling = true;\n\n// -----------------------------------------------------------------------------\n// Land or remove (moderate effort)\n//\n// Flags that can be probably deleted or landed, but might require extra effort\n// like migrating internal callers or performance testing.\n// -----------------------------------------------------------------------------\n\n// TODO: Finish rolling out in www\nexport const favorSafetyOverHydrationPerf = true;\n\n// Need to remove didTimeout argument from Scheduler before landing\nexport const disableSchedulerTimeoutInWorkLoop = false;\n\n// TODO: Land at Meta before removing.\nexport const disableDefaultPropsExceptForClasses = true;\n\n// -----------------------------------------------------------------------------\n// Slated for removal in the future (significant effort)\n//\n// These are experiments that didn't work out, and never shipped, but we can't\n// delete from the codebase until we migrate internal callers.\n// -----------------------------------------------------------------------------\n\n// Add a callback property to suspense to notify which promises are currently\n// in the update queue. This allows reporting and tracing of what is causing\n// the user to see a loading state.\n//\n// Also allows hydration callbacks to fire when a dehydrated boundary gets\n// hydrated or deleted.\n//\n// This will eventually be replaced by the Transition Tracing proposal.\nexport const enableSuspenseCallback = false;\n\n// Experimental Scope support.\nexport const enableScopeAPI = false;\n\n// Experimental Create Event Handle API.\nexport const enableCreateEventHandleAPI = false;\n\n// Support legacy Primer support on internal FB www\nexport const enableLegacyFBSupport = false;\n\n// -----------------------------------------------------------------------------\n// Ongoing experiments\n//\n// These are features that we're either actively exploring or are reasonably\n// likely to include in an upcoming release.\n// -----------------------------------------------------------------------------\n\n// Yield to the browser event loop and not just the scheduler event loop before passive effects.\n// Fix gated tests that fail with this flag enabled before turning it back on.\nexport const enableYieldingBeforePassive = false;\n\n// Experiment to intentionally yield less to block high framerate animations.\nexport const enableThrottledScheduling = false;\n\nexport const enableLegacyCache = __EXPERIMENTAL__;\n\nexport const enableAsyncIterableChildren = __EXPERIMENTAL__;\n\nexport const enableTaint = __EXPERIMENTAL__;\n\nexport const enablePostpone = __EXPERIMENTAL__;\n\nexport const enableHalt = __EXPERIMENTAL__;\n\nexport const enableViewTransition = __EXPERIMENTAL__;\n\nexport const enableSwipeTransition = __EXPERIMENTAL__;\n\nexport const enableScrollEndPolyfill = __EXPERIMENTAL__;\n\n/**\n * Switches the Fabric API from doing layout in commit work instead of complete work.\n */\nexport const enableFabricCompleteRootInCommitPhase = false;\n\n/**\n * Switches Fiber creation to a simple object instead of a constructor.\n */\nexport const enableObjectFiber = false;\n\nexport const enableTransitionTracing = false;\n\n// FB-only usage. The new API has different semantics.\nexport const enableLegacyHidden = false;\n\n// Enables unstable_avoidThisFallback feature in Fiber\nexport const enableSuspenseAvoidThisFallback = false;\n\nexport const enableCPUSuspense = __EXPERIMENTAL__;\n\n// Test this at Meta before enabling.\nexport const enableNoCloningMemoCache = false;\n\nexport const enableUseEffectEventHook = __EXPERIMENTAL__;\n\n// Test in www before enabling in open source.\n// Enables DOM-server to stream its instruction set as data-attributes\n// (handled with an MutationObserver) instead of inline-scripts\nexport const enableFizzExternalRuntime = __EXPERIMENTAL__;\n\nexport const alwaysThrottleRetries = true;\n\nexport const passChildrenWhenCloningPersistedNodes = false;\n\n/**\n * Enables a new Fiber flag used in persisted mode to reduce the number\n * of cloned host components.\n */\nexport const enablePersistedModeClonedFlag = false;\n\nexport const enableShallowPropDiffing = false;\n\nexport const enableSiblingPrerendering = true;\n\n/**\n * Enables an expiration time for retry lanes to avoid starvation.\n */\nexport const enableRetryLaneExpiration = false;\nexport const retryLaneExpirationMs = 5000;\nexport const syncLaneExpirationMs = 250;\nexport const transitionLaneExpirationMs = 5000;\n\n/**\n * Enables a new error detection for infinite render loops from updates caused\n * by setState or similar outside of the component owning the state.\n */\nexport const enableInfiniteRenderLoopDetection = false;\n\n/**\n * Experimental new hook for better managing resources in effects.\n */\nexport const enableUseEffectCRUDOverload = false;\n\nexport const enableFastAddPropertiesInDiffing = true;\nexport const enableLazyPublicInstanceInFabric = false;\n\nexport const enableFragmentRefs = __EXPERIMENTAL__;\n\n// -----------------------------------------------------------------------------\n// Ready for next major.\n//\n// Alias __NEXT_MAJOR__ to __EXPERIMENTAL__ for easier skimming.\n// -----------------------------------------------------------------------------\n\n// TODO: Anything that's set to `true` in this section should either be cleaned\n// up (if it's on everywhere, including Meta and RN builds) or moved to a\n// different section of this file.\n\n// const __NEXT_MAJOR__ = __EXPERIMENTAL__;\n\n// Renames the internal symbol for elements since they have changed signature/constructor\nexport const renameElementSymbol = true;\n\n/**\n * Enables a fix to run insertion effect cleanup on hidden subtrees.\n */\nexport const enableHiddenSubtreeInsertionEffectCleanup = false;\n\n/**\n * Removes legacy style context defined using static `contextTypes` and consumed with static `childContextTypes`.\n */\nexport const disableLegacyContext = true;\n/**\n * Removes legacy style context just from function components.\n */\nexport const disableLegacyContextForFunctionComponents = true;\n\n// Enable the moveBefore() alternative to insertBefore(). This preserves states of moves.\nexport const enableMoveBefore = __EXPERIMENTAL__;\n\n// Disabled caching behavior of `react/cache` in client runtimes.\nexport const disableClientCache = true;\n\n// Warn on any usage of ReactTestRenderer\nexport const enableReactTestRendererWarning = true;\n\n// Disables legacy mode\n// This allows us to land breaking changes to remove legacy mode APIs in experimental builds\n// before removing them in stable in the next Major\nexport const disableLegacyMode = true;\n\n// Make <Context> equivalent to <Context.Provider> instead of <Context.Consumer>\nexport const enableRenderableContext = true;\n\n// -----------------------------------------------------------------------------\n// Chopping Block\n//\n// Planned feature deprecations and breaking changes. Sorted roughly in order of\n// when we plan to enable them.\n// -----------------------------------------------------------------------------\n\n// -----------------------------------------------------------------------------\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nexport const disableCommentsAsDOMContainers = true;\n\nexport const enableTrustedTypesIntegration = false;\n\n// Prevent the value and checked attributes from syncing with their related\n// DOM properties\nexport const disableInputAttributeSyncing = false;\n\n// Disables children for <textarea> elements\nexport const disableTextareaChildren = false;\n\n// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n\n// Gather advanced timing metrics for Profiler subtrees.\nexport const enableProfilerTimer = __PROFILE__;\n\n// Adds performance.measure() marks using Chrome extensions to allow formatted\n// Component rendering tracks to show up in the Performance tab.\n// This flag will be used for both Server Component and Client Component tracks.\n// All calls should also be gated on enableProfilerTimer.\nexport const enableComponentPerformanceTrack = __EXPERIMENTAL__;\n\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nexport const enableSchedulingProfiler: boolean =\n  !enableComponentPerformanceTrack && __PROFILE__;\n\n// Record durations for commit and passive effects phases.\nexport const enableProfilerCommitHooks = __PROFILE__;\n\n// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nexport const enableProfilerNestedUpdatePhase = __PROFILE__;\n\nexport const enableAsyncDebugInfo = __EXPERIMENTAL__;\n\n// Track which Fiber(s) schedule render work.\nexport const enableUpdaterTracking = __PROFILE__;\n\n// Internal only.\nexport const enableDO_NOT_USE_disableStrictPassiveEffect = false;\n\nexport const ownerStackLimit = 1e4;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/**\n * HTML nodeType values that represent the type of the node\n */\n\nexport const ELEMENT_NODE = 1;\nexport const TEXT_NODE = 3;\nexport const COMMENT_NODE = 8;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_TYPE_NODE = 10;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {disableCommentsAsDOMContainers} from 'shared/ReactFeatureFlags';\n\nimport {\n  ELEMENT_NODE,\n  COMMENT_NODE,\n  DOCUMENT_NODE,\n  DOCUMENT_FRAGMENT_NODE,\n} from './HTMLNodeType';\n\nexport function isValidContainer(node: any): boolean {\n  return !!(\n    node &&\n    (node.nodeType === ELEMENT_NODE ||\n      node.nodeType === DOCUMENT_NODE ||\n      node.nodeType === DOCUMENT_FRAGMENT_NODE ||\n      (!disableCommentsAsDOMContainers &&\n        node.nodeType === COMMENT_NODE &&\n        (node: any).nodeValue === ' react-mount-point-unstable '))\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_PROVIDER_TYPE: symbol = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value: mixed): string {\n  if (__DEV__) {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    const hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    const type =\n      (hasToStringTag && (value: any)[Symbol.toStringTag]) ||\n      (value: any).constructor.name ||\n      'Object';\n    // $FlowFixMe[incompatible-return]\n    return type;\n  }\n}\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value: mixed): boolean {\n  if (__DEV__) {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\n/** @noinline */\nfunction testStringCoercion(value: mixed) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + (value: any);\n}\n\nexport function checkAttributeStringCoercion(\n  value: mixed,\n  attributeName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` attribute is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        attributeName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkKeyStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided key is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkPropStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` prop is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkOptionStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` option is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkCSSPropertyStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` CSS property is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkHtmlStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided HTML markup uses a value of unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkFormFieldValueStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'Form field values (value, checked, defaultValue, or defaultChecked props)' +\n          ' must be strings, not %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {REACT_PORTAL_TYPE} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\n\nimport type {ReactNodeList, ReactPortal} from 'shared/ReactTypes';\n\nexport function createPortal(\n  children: ReactNodeList,\n  containerInfo: any,\n  // TODO: figure out the API for cross-renderer implementation.\n  implementation: any,\n  key: ?string = null,\n): ReactPortal {\n  if (__DEV__) {\n    checkKeyStringCoercion(key);\n  }\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children,\n    containerInfo,\n    implementation,\n  };\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {Transition} from './ReactFiberTracingMarkerComponent';\nimport type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates';\n\n// TODO: Ideally these types would be opaque but that doesn't work well with\n// our reconciler fork infra, since these leak into non-reconciler packages.\n\nexport type Lanes = number;\nexport type Lane = number;\nexport type LaneMap<T> = Array<T>;\n\nimport {\n  enableRetryLaneExpiration,\n  enableSchedulingProfiler,\n  enableTransitionTracing,\n  enableUpdaterTracking,\n  syncLaneExpirationMs,\n  transitionLaneExpirationMs,\n  retryLaneExpirationMs,\n  disableLegacyMode,\n  enableSiblingPrerendering,\n} from 'shared/ReactFeatureFlags';\nimport {isDevToolsPresent} from './ReactFiberDevToolsHook';\nimport {clz32} from './clz32';\nimport {LegacyRoot} from './ReactRootTags';\n\n// Lane values below should be kept in sync with getLabelForLane(), used by react-devtools-timeline.\n// If those values are changed that package should be rebuilt and redeployed.\n\nexport const TotalLanes = 31;\n\nexport const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;\nexport const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;\n\nexport const SyncHydrationLane: Lane = /*               */ 0b0000000000000000000000000000001;\nexport const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000010;\nexport const SyncLaneIndex: number = 1;\n\nexport const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000100;\nexport const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000001000;\n\nexport const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000;\nexport const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000;\n\nexport const SyncUpdateLanes: Lane =\n  SyncLane | InputContinuousLane | DefaultLane;\n\nexport const GestureLane: Lane = /*                     */ 0b0000000000000000000000001000000;\n\nconst TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000010000000;\nconst TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111100000000;\nconst TransitionLane1: Lane = /*                        */ 0b0000000000000000000000100000000;\nconst TransitionLane2: Lane = /*                        */ 0b0000000000000000000001000000000;\nconst TransitionLane3: Lane = /*                        */ 0b0000000000000000000010000000000;\nconst TransitionLane4: Lane = /*                        */ 0b0000000000000000000100000000000;\nconst TransitionLane5: Lane = /*                        */ 0b0000000000000000001000000000000;\nconst TransitionLane6: Lane = /*                        */ 0b0000000000000000010000000000000;\nconst TransitionLane7: Lane = /*                        */ 0b0000000000000000100000000000000;\nconst TransitionLane8: Lane = /*                        */ 0b0000000000000001000000000000000;\nconst TransitionLane9: Lane = /*                        */ 0b0000000000000010000000000000000;\nconst TransitionLane10: Lane = /*                       */ 0b0000000000000100000000000000000;\nconst TransitionLane11: Lane = /*                       */ 0b0000000000001000000000000000000;\nconst TransitionLane12: Lane = /*                       */ 0b0000000000010000000000000000000;\nconst TransitionLane13: Lane = /*                       */ 0b0000000000100000000000000000000;\nconst TransitionLane14: Lane = /*                       */ 0b0000000001000000000000000000000;\n\nconst RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;\nconst RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;\nconst RetryLane2: Lane = /*                             */ 0b0000000100000000000000000000000;\nconst RetryLane3: Lane = /*                             */ 0b0000001000000000000000000000000;\nconst RetryLane4: Lane = /*                             */ 0b0000010000000000000000000000000;\n\nexport const SomeRetryLane: Lane = RetryLane1;\n\nexport const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;\n\nconst NonIdleLanes: Lanes = /*                          */ 0b0000111111111111111111111111111;\n\nexport const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;\nexport const IdleLane: Lane = /*                        */ 0b0010000000000000000000000000000;\n\nexport const OffscreenLane: Lane = /*                   */ 0b0100000000000000000000000000000;\nexport const DeferredLane: Lane = /*                    */ 0b1000000000000000000000000000000;\n\n// Any lane that might schedule an update. This is used to detect infinite\n// update loops, so it doesn't include hydration lanes or retries.\nexport const UpdateLanes: Lanes =\n  SyncLane | InputContinuousLane | DefaultLane | TransitionLanes;\n\nexport const HydrationLanes =\n  SyncHydrationLane |\n  InputContinuousHydrationLane |\n  DefaultHydrationLane |\n  TransitionHydrationLane |\n  SelectiveHydrationLane |\n  IdleHydrationLane;\n\n// This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\nexport function getLabelForLane(lane: Lane): string | void {\n  if (enableSchedulingProfiler) {\n    if (lane & SyncHydrationLane) {\n      return 'SyncHydrationLane';\n    }\n    if (lane & SyncLane) {\n      return 'Sync';\n    }\n    if (lane & InputContinuousHydrationLane) {\n      return 'InputContinuousHydration';\n    }\n    if (lane & InputContinuousLane) {\n      return 'InputContinuous';\n    }\n    if (lane & DefaultHydrationLane) {\n      return 'DefaultHydration';\n    }\n    if (lane & DefaultLane) {\n      return 'Default';\n    }\n    if (lane & TransitionHydrationLane) {\n      return 'TransitionHydration';\n    }\n    if (lane & TransitionLanes) {\n      return 'Transition';\n    }\n    if (lane & RetryLanes) {\n      return 'Retry';\n    }\n    if (lane & SelectiveHydrationLane) {\n      return 'SelectiveHydration';\n    }\n    if (lane & IdleHydrationLane) {\n      return 'IdleHydration';\n    }\n    if (lane & IdleLane) {\n      return 'Idle';\n    }\n    if (lane & OffscreenLane) {\n      return 'Offscreen';\n    }\n    if (lane & DeferredLane) {\n      return 'Deferred';\n    }\n  }\n}\n\nexport const NoTimestamp = -1;\n\nlet nextTransitionLane: Lane = TransitionLane1;\nlet nextRetryLane: Lane = RetryLane1;\n\nfunction getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {\n  const pendingSyncLanes = lanes & SyncUpdateLanes;\n  if (pendingSyncLanes !== 0) {\n    return pendingSyncLanes;\n  }\n  switch (getHighestPriorityLane(lanes)) {\n    case SyncHydrationLane:\n      return SyncHydrationLane;\n    case SyncLane:\n      return SyncLane;\n    case InputContinuousHydrationLane:\n      return InputContinuousHydrationLane;\n    case InputContinuousLane:\n      return InputContinuousLane;\n    case DefaultHydrationLane:\n      return DefaultHydrationLane;\n    case DefaultLane:\n      return DefaultLane;\n    case GestureLane:\n      return GestureLane;\n    case TransitionHydrationLane:\n      return TransitionHydrationLane;\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n      return lanes & TransitionLanes;\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n      return lanes & RetryLanes;\n    case SelectiveHydrationLane:\n      return SelectiveHydrationLane;\n    case IdleHydrationLane:\n      return IdleHydrationLane;\n    case IdleLane:\n      return IdleLane;\n    case OffscreenLane:\n      return OffscreenLane;\n    case DeferredLane:\n      // This shouldn't be reachable because deferred work is always entangled\n      // with something else.\n      return NoLanes;\n    default:\n      if (__DEV__) {\n        console.error(\n          'Should have found matching lanes. This is a bug in React.',\n        );\n      }\n      // This shouldn't be reachable, but as a fallback, return the entire bitmask.\n      return lanes;\n  }\n}\n\nexport function getNextLanes(\n  root: FiberRoot,\n  wipLanes: Lanes,\n  rootHasPendingCommit: boolean,\n): Lanes {\n  // Early bailout if there's no pending work left.\n  const pendingLanes = root.pendingLanes;\n  if (pendingLanes === NoLanes) {\n    return NoLanes;\n  }\n\n  let nextLanes: Lanes = NoLanes;\n\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes;\n  const warmLanes = root.warmLanes;\n\n  // finishedLanes represents a completed tree that is ready to commit.\n  //\n  // It's not worth doing discarding the completed tree in favor of performing\n  // speculative work. So always check this before deciding to warm up\n  // the siblings.\n  //\n  // Note that this is not set in a \"suspend indefinitely\" scenario, like when\n  // suspending outside of a Suspense boundary, or in the shell during a\n  // transition â€” only in cases where we are very likely to commit the tree in\n  // a brief amount of time (i.e. below the \"Just Noticeable Difference\"\n  // threshold).\n  //\n\n  // Do not work on any idle work until all the non-idle work has finished,\n  // even if the work is suspended.\n  const nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n  if (nonIdlePendingLanes !== NoLanes) {\n    // First check for fresh updates.\n    const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n    if (nonIdleUnblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n    } else {\n      // No fresh updates. Check if suspended work has been pinged.\n      const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n      if (nonIdlePingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n      } else {\n        if (enableSiblingPrerendering) {\n          // Nothing has been pinged. Check for lanes that need to be prewarmed.\n          if (!rootHasPendingCommit) {\n            const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;\n            if (lanesToPrewarm !== NoLanes) {\n              nextLanes = getHighestPriorityLanes(lanesToPrewarm);\n            }\n          }\n        }\n      }\n    }\n  } else {\n    // The only remaining work is Idle.\n    // TODO: Idle isn't really used anywhere, and the thinking around\n    // speculative rendering has evolved since this was implemented. Consider\n    // removing until we've thought about this again.\n\n    // First check for fresh updates.\n    const unblockedLanes = pendingLanes & ~suspendedLanes;\n    if (unblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(unblockedLanes);\n    } else {\n      // No fresh updates. Check if suspended work has been pinged.\n      if (pingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(pingedLanes);\n      } else {\n        if (enableSiblingPrerendering) {\n          // Nothing has been pinged. Check for lanes that need to be prewarmed.\n          if (!rootHasPendingCommit) {\n            const lanesToPrewarm = pendingLanes & ~warmLanes;\n            if (lanesToPrewarm !== NoLanes) {\n              nextLanes = getHighestPriorityLanes(lanesToPrewarm);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (nextLanes === NoLanes) {\n    // This should only be reachable if we're suspended\n    // TODO: Consider warning in this path if a fallback timer is not scheduled.\n    return NoLanes;\n  }\n\n  // If we're already in the middle of a render, switching lanes will interrupt\n  // it and we'll lose our progress. We should only do this if the new lanes are\n  // higher priority.\n  if (\n    wipLanes !== NoLanes &&\n    wipLanes !== nextLanes &&\n    // If we already suspended with a delay, then interrupting is fine. Don't\n    // bother waiting until the root is complete.\n    (wipLanes & suspendedLanes) === NoLanes\n  ) {\n    const nextLane = getHighestPriorityLane(nextLanes);\n    const wipLane = getHighestPriorityLane(wipLanes);\n    if (\n      // Tests whether the next lane is equal or lower priority than the wip\n      // one. This works because the bits decrease in priority as you go left.\n      nextLane >= wipLane ||\n      // Default priority updates should not interrupt transition updates. The\n      // only difference between default updates and transition updates is that\n      // default updates do not support refresh transitions.\n      (nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes)\n    ) {\n      // Keep working on the existing in-progress tree. Do not interrupt.\n      return wipLanes;\n    }\n  }\n\n  return nextLanes;\n}\n\nexport function getNextLanesToFlushSync(\n  root: FiberRoot,\n  extraLanesToForceSync: Lane | Lanes,\n): Lanes {\n  // Similar to getNextLanes, except instead of choosing the next lanes to work\n  // on based on their priority, it selects all the lanes that have equal or\n  // higher priority than those are given. That way they can be synchronously\n  // rendered in a single batch.\n  //\n  // The main use case is updates scheduled by popstate events, which are\n  // flushed synchronously even though they are transitions.\n  // Note that we intentionally treat this as a sync flush to include any\n  // sync updates in a single pass but also intentionally disables View Transitions\n  // inside popstate. Because they can start synchronously before scroll restoration\n  // happens.\n  const lanesToFlush = SyncUpdateLanes | extraLanesToForceSync;\n\n  // Early bailout if there's no pending work left.\n  const pendingLanes = root.pendingLanes;\n  if (pendingLanes === NoLanes) {\n    return NoLanes;\n  }\n\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes;\n\n  // Remove lanes that are suspended (but not pinged)\n  const unblockedLanes = pendingLanes & ~(suspendedLanes & ~pingedLanes);\n  const unblockedLanesWithMatchingPriority =\n    unblockedLanes & getLanesOfEqualOrHigherPriority(lanesToFlush);\n\n  // If there are matching hydration lanes, we should do those by themselves.\n  // Hydration lanes must never include updates.\n  if (unblockedLanesWithMatchingPriority & HydrationLanes) {\n    return (\n      (unblockedLanesWithMatchingPriority & HydrationLanes) | SyncHydrationLane\n    );\n  }\n\n  if (unblockedLanesWithMatchingPriority) {\n    // Always include the SyncLane as part of the result, even if there's no\n    // pending sync work, to indicate the priority of the entire batch of work\n    // is considered Sync.\n    return unblockedLanesWithMatchingPriority | SyncLane;\n  }\n\n  return NoLanes;\n}\n\nexport function checkIfRootIsPrerendering(\n  root: FiberRoot,\n  renderLanes: Lanes,\n): boolean {\n  const pendingLanes = root.pendingLanes;\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes;\n  // Remove lanes that are suspended (but not pinged)\n  const unblockedLanes = pendingLanes & ~(suspendedLanes & ~pingedLanes);\n\n  // If there are no unsuspended or pinged lanes, that implies that we're\n  // performing a prerender.\n  return (unblockedLanes & renderLanes) === 0;\n}\n\nexport function getEntangledLanes(root: FiberRoot, renderLanes: Lanes): Lanes {\n  let entangledLanes = renderLanes;\n\n  if ((entangledLanes & InputContinuousLane) !== NoLanes) {\n    // When updates are sync by default, we entangle continuous priority updates\n    // and default updates, so they render in the same batch. The only reason\n    // they use separate lanes is because continuous updates should interrupt\n    // transitions, but default updates should not.\n    entangledLanes |= entangledLanes & DefaultLane;\n  }\n\n  // Check for entangled lanes and add them to the batch.\n  //\n  // A lane is said to be entangled with another when it's not allowed to render\n  // in a batch that does not also include the other lane. Typically we do this\n  // when multiple updates have the same source, and we only want to respond to\n  // the most recent event from that source.\n  //\n  // Note that we apply entanglements *after* checking for partial work above.\n  // This means that if a lane is entangled during an interleaved event while\n  // it's already rendering, we won't interrupt it. This is intentional, since\n  // entanglement is usually \"best effort\": we'll try our best to render the\n  // lanes in the same batch, but it's not worth throwing out partially\n  // completed work in order to do it.\n  // TODO: Reconsider this. The counter-argument is that the partial work\n  // represents an intermediate state, which we don't want to show to the user.\n  // And by spending extra time finishing it, we're increasing the amount of\n  // time it takes to show the final state, which is what they are actually\n  // waiting for.\n  //\n  // For those exceptions where entanglement is semantically important,\n  // we should ensure that there is no partial work at the\n  // time we apply the entanglement.\n  const allEntangledLanes = root.entangledLanes;\n  if (allEntangledLanes !== NoLanes) {\n    const entanglements = root.entanglements;\n    let lanes = entangledLanes & allEntangledLanes;\n    while (lanes > 0) {\n      const index = pickArbitraryLaneIndex(lanes);\n      const lane = 1 << index;\n\n      entangledLanes |= entanglements[index];\n\n      lanes &= ~lane;\n    }\n  }\n\n  return entangledLanes;\n}\n\nfunction computeExpirationTime(lane: Lane, currentTime: number) {\n  switch (lane) {\n    case SyncHydrationLane:\n    case SyncLane:\n    case InputContinuousHydrationLane:\n    case InputContinuousLane:\n    case GestureLane:\n      // User interactions should expire slightly more quickly.\n      //\n      // NOTE: This is set to the corresponding constant as in Scheduler.js.\n      // When we made it larger, a product metric in www regressed, suggesting\n      // there's a user interaction that's being starved by a series of\n      // synchronous updates. If that theory is correct, the proper solution is\n      // to fix the starvation. However, this scenario supports the idea that\n      // expiration times are an important safeguard when starvation\n      // does happen.\n      return currentTime + syncLaneExpirationMs;\n    case DefaultHydrationLane:\n    case DefaultLane:\n    case TransitionHydrationLane:\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n      return currentTime + transitionLaneExpirationMs;\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n      // TODO: Retries should be allowed to expire if they are CPU bound for\n      // too long, but when I made this change it caused a spike in browser\n      // crashes. There must be some other underlying bug; not super urgent but\n      // ideally should figure out why and fix it. Unfortunately we don't have\n      // a repro for the crashes, only detected via production metrics.\n      return enableRetryLaneExpiration\n        ? currentTime + retryLaneExpirationMs\n        : NoTimestamp;\n    case SelectiveHydrationLane:\n    case IdleHydrationLane:\n    case IdleLane:\n    case OffscreenLane:\n    case DeferredLane:\n      // Anything idle priority or lower should never expire.\n      return NoTimestamp;\n    default:\n      if (__DEV__) {\n        console.error(\n          'Should have found matching lanes. This is a bug in React.',\n        );\n      }\n      return NoTimestamp;\n  }\n}\n\nexport function markStarvedLanesAsExpired(\n  root: FiberRoot,\n  currentTime: number,\n): void {\n  // TODO: This gets called every time we yield. We can optimize by storing\n  // the earliest expiration time on the root. Then use that to quickly bail out\n  // of this function.\n\n  const pendingLanes = root.pendingLanes;\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes;\n  const expirationTimes = root.expirationTimes;\n\n  // Iterate through the pending lanes and check if we've reached their\n  // expiration time. If so, we'll assume the update is being starved and mark\n  // it as expired to force it to finish.\n  // TODO: We should be able to replace this with upgradePendingLanesToSync\n  //\n  // We exclude retry lanes because those must always be time sliced, in order\n  // to unwrap uncached promises.\n  // TODO: Write a test for this\n  let lanes = enableRetryLaneExpiration\n    ? pendingLanes\n    : pendingLanes & ~RetryLanes;\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    const expirationTime = expirationTimes[index];\n    if (expirationTime === NoTimestamp) {\n      // Found a pending lane with no expiration time. If it's not suspended, or\n      // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n      // using the current time.\n      if (\n        (lane & suspendedLanes) === NoLanes ||\n        (lane & pingedLanes) !== NoLanes\n      ) {\n        // Assumes timestamps are monotonically increasing.\n        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n      }\n    } else if (expirationTime <= currentTime) {\n      // This lane expired\n      root.expiredLanes |= lane;\n    }\n\n    lanes &= ~lane;\n  }\n}\n\n// This returns the highest priority pending lanes regardless of whether they\n// are suspended.\nexport function getHighestPriorityPendingLanes(root: FiberRoot): Lanes {\n  return getHighestPriorityLanes(root.pendingLanes);\n}\n\nexport function getLanesToRetrySynchronouslyOnError(\n  root: FiberRoot,\n  originallyAttemptedLanes: Lanes,\n): Lanes {\n  if (root.errorRecoveryDisabledLanes & originallyAttemptedLanes) {\n    // The error recovery mechanism is disabled until these lanes are cleared.\n    return NoLanes;\n  }\n\n  const everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n  if (everythingButOffscreen !== NoLanes) {\n    return everythingButOffscreen;\n  }\n  if (everythingButOffscreen & OffscreenLane) {\n    return OffscreenLane;\n  }\n  return NoLanes;\n}\n\nexport function includesSyncLane(lanes: Lanes): boolean {\n  return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;\n}\n\nexport function isSyncLane(lanes: Lanes): boolean {\n  return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;\n}\n\nexport function includesNonIdleWork(lanes: Lanes): boolean {\n  return (lanes & NonIdleLanes) !== NoLanes;\n}\nexport function includesOnlyRetries(lanes: Lanes): boolean {\n  return (lanes & RetryLanes) === lanes;\n}\nexport function includesOnlyNonUrgentLanes(lanes: Lanes): boolean {\n  // TODO: Should hydration lanes be included here? This function is only\n  // used in `updateDeferredValueImpl`.\n  const UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n  return (lanes & UrgentLanes) === NoLanes;\n}\nexport function includesOnlyTransitions(lanes: Lanes): boolean {\n  return (lanes & TransitionLanes) === lanes;\n}\n\nexport function includesTransitionLane(lanes: Lanes): boolean {\n  return (lanes & TransitionLanes) !== NoLanes;\n}\n\nexport function includesOnlyHydrationLanes(lanes: Lanes): boolean {\n  return (lanes & HydrationLanes) === lanes;\n}\n\nexport function includesOnlyOffscreenLanes(lanes: Lanes): boolean {\n  return (lanes & OffscreenLane) === lanes;\n}\n\nexport function includesOnlyHydrationOrOffscreenLanes(lanes: Lanes): boolean {\n  return (lanes & (HydrationLanes | OffscreenLane)) === lanes;\n}\n\nexport function includesOnlyViewTransitionEligibleLanes(lanes: Lanes): boolean {\n  return (lanes & (TransitionLanes | RetryLanes | IdleLane)) === lanes;\n}\n\nexport function includesBlockingLane(lanes: Lanes): boolean {\n  const SyncDefaultLanes =\n    InputContinuousHydrationLane |\n    InputContinuousLane |\n    DefaultHydrationLane |\n    DefaultLane |\n    GestureLane;\n  return (lanes & SyncDefaultLanes) !== NoLanes;\n}\n\nexport function includesExpiredLane(root: FiberRoot, lanes: Lanes): boolean {\n  // This is a separate check from includesBlockingLane because a lane can\n  // expire after a render has already started.\n  return (lanes & root.expiredLanes) !== NoLanes;\n}\n\nexport function isBlockingLane(lane: Lane): boolean {\n  const SyncDefaultLanes =\n    InputContinuousHydrationLane |\n    InputContinuousLane |\n    DefaultHydrationLane |\n    DefaultLane;\n  return (lane & SyncDefaultLanes) !== NoLanes;\n}\n\nexport function isTransitionLane(lane: Lane): boolean {\n  return (lane & TransitionLanes) !== NoLanes;\n}\n\nexport function isGestureRender(lanes: Lanes): boolean {\n  // This should render only the one lane.\n  return lanes === GestureLane;\n}\n\nexport function claimNextTransitionLane(): Lane {\n  // Cycle through the lanes, assigning each new transition to the next lane.\n  // In most cases, this means every transition gets its own lane, until we\n  // run out of lanes and cycle back to the beginning.\n  const lane = nextTransitionLane;\n  nextTransitionLane <<= 1;\n  if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n    nextTransitionLane = TransitionLane1;\n  }\n  return lane;\n}\n\nexport function claimNextRetryLane(): Lane {\n  const lane = nextRetryLane;\n  nextRetryLane <<= 1;\n  if ((nextRetryLane & RetryLanes) === NoLanes) {\n    nextRetryLane = RetryLane1;\n  }\n  return lane;\n}\n\nexport function getHighestPriorityLane(lanes: Lanes): Lane {\n  return lanes & -lanes;\n}\n\nfunction getLanesOfEqualOrHigherPriority(lanes: Lane | Lanes): Lanes {\n  // Create a mask with all bits to the right or same as the highest bit.\n  // So if lanes is 0b100, the result would be 0b111.\n  // If lanes is 0b101, the result would be 0b111.\n  const lowestPriorityLaneIndex = 31 - clz32(lanes);\n  return (1 << (lowestPriorityLaneIndex + 1)) - 1;\n}\n\nexport function pickArbitraryLane(lanes: Lanes): Lane {\n  // This wrapper function gets inlined. Only exists so to communicate that it\n  // doesn't matter which bit is selected; you can pick any bit without\n  // affecting the algorithms where its used. Here I'm using\n  // getHighestPriorityLane because it requires the fewest operations.\n  return getHighestPriorityLane(lanes);\n}\n\nfunction pickArbitraryLaneIndex(lanes: Lanes) {\n  return 31 - clz32(lanes);\n}\n\nfunction laneToIndex(lane: Lane) {\n  return pickArbitraryLaneIndex(lane);\n}\n\nexport function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane): boolean {\n  return (a & b) !== NoLanes;\n}\n\nexport function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane): boolean {\n  return (set & subset) === subset;\n}\n\nexport function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\n  return a | b;\n}\n\nexport function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {\n  return set & ~subset;\n}\n\nexport function intersectLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\n  return a & b;\n}\n\n// Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\nexport function laneToLanes(lane: Lane): Lanes {\n  return lane;\n}\n\nexport function higherPriorityLane(a: Lane, b: Lane): Lane {\n  // This works because the bit ranges decrease in priority as you go left.\n  return a !== NoLane && a < b ? a : b;\n}\n\nexport function createLaneMap<T>(initial: T): LaneMap<T> {\n  // Intentionally pushing one by one.\n  // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n  const laneMap = [];\n  for (let i = 0; i < TotalLanes; i++) {\n    laneMap.push(initial);\n  }\n  return laneMap;\n}\n\nexport function markRootUpdated(root: FiberRoot, updateLane: Lane) {\n  root.pendingLanes |= updateLane;\n\n  // If there are any suspended transitions, it's possible this new update\n  // could unblock them. Clear the suspended lanes so that we can try rendering\n  // them again.\n  //\n  // TODO: We really only need to unsuspend only lanes that are in the\n  // `subtreeLanes` of the updated fiber, or the update lanes of the return\n  // path. This would exclude suspended updates in an unrelated sibling tree,\n  // since there's no way for this update to unblock it.\n  //\n  // We don't do this if the incoming update is idle, because we never process\n  // idle updates until after all the regular updates have finished; there's no\n  // way it could unblock a transition.\n  if (updateLane !== IdleLane) {\n    root.suspendedLanes = NoLanes;\n    root.pingedLanes = NoLanes;\n    root.warmLanes = NoLanes;\n  }\n}\n\nexport function markRootSuspended(\n  root: FiberRoot,\n  suspendedLanes: Lanes,\n  spawnedLane: Lane,\n  didAttemptEntireTree: boolean,\n) {\n  // TODO: Split this into separate functions for marking the root at the end of\n  // a render attempt versus suspending while the root is still in progress.\n  root.suspendedLanes |= suspendedLanes;\n  root.pingedLanes &= ~suspendedLanes;\n\n  if (enableSiblingPrerendering && didAttemptEntireTree) {\n    // Mark these lanes as warm so we know there's nothing else to work on.\n    root.warmLanes |= suspendedLanes;\n  } else {\n    // Render unwound without attempting all the siblings. Do no mark the lanes\n    // as warm. This will cause a prewarm render to be scheduled.\n  }\n\n  // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n  const expirationTimes = root.expirationTimes;\n  let lanes = suspendedLanes;\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    expirationTimes[index] = NoTimestamp;\n\n    lanes &= ~lane;\n  }\n\n  if (spawnedLane !== NoLane) {\n    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n  }\n}\n\nexport function markRootPinged(root: FiberRoot, pingedLanes: Lanes) {\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\n  // The data that just resolved could have unblocked additional children, which\n  // will also need to be prewarmed if something suspends again.\n  root.warmLanes &= ~pingedLanes;\n}\n\nexport function markRootFinished(\n  root: FiberRoot,\n  finishedLanes: Lanes,\n  remainingLanes: Lanes,\n  spawnedLane: Lane,\n  updatedLanes: Lanes,\n  suspendedRetryLanes: Lanes,\n) {\n  const previouslyPendingLanes = root.pendingLanes;\n  const noLongerPendingLanes = previouslyPendingLanes & ~remainingLanes;\n\n  root.pendingLanes = remainingLanes;\n\n  // Let's try everything again\n  root.suspendedLanes = NoLanes;\n  root.pingedLanes = NoLanes;\n  root.warmLanes = NoLanes;\n\n  root.expiredLanes &= remainingLanes;\n\n  root.entangledLanes &= remainingLanes;\n\n  root.errorRecoveryDisabledLanes &= remainingLanes;\n  root.shellSuspendCounter = 0;\n\n  const entanglements = root.entanglements;\n  const expirationTimes = root.expirationTimes;\n  const hiddenUpdates = root.hiddenUpdates;\n\n  // Clear the lanes that no longer have pending work\n  let lanes = noLongerPendingLanes;\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    entanglements[index] = NoLanes;\n    expirationTimes[index] = NoTimestamp;\n\n    const hiddenUpdatesForLane = hiddenUpdates[index];\n    if (hiddenUpdatesForLane !== null) {\n      hiddenUpdates[index] = null;\n      // \"Hidden\" updates are updates that were made to a hidden component. They\n      // have special logic associated with them because they may be entangled\n      // with updates that occur outside that tree. But once the outer tree\n      // commits, they behave like regular updates.\n      for (let i = 0; i < hiddenUpdatesForLane.length; i++) {\n        const update = hiddenUpdatesForLane[i];\n        if (update !== null) {\n          update.lane &= ~OffscreenLane;\n        }\n      }\n    }\n\n    lanes &= ~lane;\n  }\n\n  if (spawnedLane !== NoLane) {\n    markSpawnedDeferredLane(\n      root,\n      spawnedLane,\n      // This render finished successfully without suspending, so we don't need\n      // to entangle the spawned task with the parent task.\n      NoLanes,\n    );\n  }\n\n  // suspendedRetryLanes represents the retry lanes spawned by new Suspense\n  // boundaries during this render that were not later pinged.\n  //\n  // These lanes were marked as pending on their associated Suspense boundary\n  // fiber during the render phase so that we could start rendering them\n  // before new data streams in. As soon as the fallback commits, we can try\n  // to render them again.\n  //\n  // But since we know they're still suspended, we can skip straight to the\n  // \"prerender\" mode (i.e. don't skip over siblings after something\n  // suspended) instead of the regular mode (i.e. unwind and skip the siblings\n  // as soon as something suspends to unblock the rest of the update).\n  if (\n    enableSiblingPrerendering &&\n    suspendedRetryLanes !== NoLanes &&\n    // Note that we only do this if there were no updates since we started\n    // rendering. This mirrors the logic in markRootUpdated â€” whenever we\n    // receive an update, we reset all the suspended and pinged lanes.\n    updatedLanes === NoLanes &&\n    !(disableLegacyMode && root.tag === LegacyRoot)\n  ) {\n    // We also need to avoid marking a retry lane as suspended if it was already\n    // pending before this render. We can't say these are now suspended if they\n    // weren't included in our attempt.\n    const freshlySpawnedRetryLanes =\n      suspendedRetryLanes &\n      // Remove any retry lane that was already pending before our just-finished\n      // attempt, and also wasn't included in that attempt.\n      ~(previouslyPendingLanes & ~finishedLanes);\n    root.suspendedLanes |= freshlySpawnedRetryLanes;\n  }\n}\n\nfunction markSpawnedDeferredLane(\n  root: FiberRoot,\n  spawnedLane: Lane,\n  entangledLanes: Lanes,\n) {\n  // This render spawned a deferred task. Mark it as pending.\n  root.pendingLanes |= spawnedLane;\n  root.suspendedLanes &= ~spawnedLane;\n\n  // Entangle the spawned lane with the DeferredLane bit so that we know it\n  // was the result of another render. This lets us avoid a useDeferredValue\n  // waterfall â€” only the first level will defer.\n  const spawnedLaneIndex = laneToIndex(spawnedLane);\n  root.entangledLanes |= spawnedLane;\n  root.entanglements[spawnedLaneIndex] |=\n    DeferredLane |\n    // If the parent render task suspended, we must also entangle those lanes\n    // with the spawned task, so that the deferred task includes all the same\n    // updates that the parent task did. We can exclude any lane that is not\n    // used for updates (e.g. Offscreen).\n    (entangledLanes & UpdateLanes);\n}\n\nexport function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {\n  // In addition to entangling each of the given lanes with each other, we also\n  // have to consider _transitive_ entanglements. For each lane that is already\n  // entangled with *any* of the given lanes, that lane is now transitively\n  // entangled with *all* the given lanes.\n  //\n  // Translated: If C is entangled with A, then entangling A with B also\n  // entangles C with B.\n  //\n  // If this is hard to grasp, it might help to intentionally break this\n  // function and look at the tests that fail in ReactTransition-test.js. Try\n  // commenting out one of the conditions below.\n\n  const rootEntangledLanes = (root.entangledLanes |= entangledLanes);\n  const entanglements = root.entanglements;\n  let lanes = rootEntangledLanes;\n  while (lanes) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    if (\n      // Is this one of the newly entangled lanes?\n      (lane & entangledLanes) |\n      // Is this lane transitively entangled with the newly entangled lanes?\n      (entanglements[index] & entangledLanes)\n    ) {\n      entanglements[index] |= entangledLanes;\n    }\n    lanes &= ~lane;\n  }\n}\n\nexport function upgradePendingLanesToSync(\n  root: FiberRoot,\n  lanesToUpgrade: Lanes,\n) {\n  // Same as upgradePendingLaneToSync but accepts multiple lanes, so it's a\n  // bit slower.\n  root.pendingLanes |= SyncLane;\n  root.entangledLanes |= SyncLane;\n  let lanes = lanesToUpgrade;\n  while (lanes) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    root.entanglements[SyncLaneIndex] |= lane;\n    lanes &= ~lane;\n  }\n}\n\nexport function markHiddenUpdate(\n  root: FiberRoot,\n  update: ConcurrentUpdate,\n  lane: Lane,\n) {\n  const index = laneToIndex(lane);\n  const hiddenUpdates = root.hiddenUpdates;\n  const hiddenUpdatesForLane = hiddenUpdates[index];\n  if (hiddenUpdatesForLane === null) {\n    hiddenUpdates[index] = [update];\n  } else {\n    hiddenUpdatesForLane.push(update);\n  }\n  update.lane = lane | OffscreenLane;\n}\n\nexport function getBumpedLaneForHydration(\n  root: FiberRoot,\n  renderLanes: Lanes,\n): Lane {\n  const renderLane = getHighestPriorityLane(renderLanes);\n  const bumpedLane =\n    (renderLane & SyncUpdateLanes) !== NoLane\n      ? // Unify sync lanes. We don't do this inside getBumpedLaneForHydrationByLane\n        // because that causes things to flush synchronously when they shouldn't.\n        // TODO: This is not coherent but that's beacuse the unification is not coherent.\n        // We need to get merge these into an actual single lane.\n        SyncHydrationLane\n      : getBumpedLaneForHydrationByLane(renderLane);\n  // Check if the lane we chose is suspended. If so, that indicates that we\n  // already attempted and failed to hydrate at that level. Also check if we're\n  // already rendering that lane, which is rare but could happen.\n  // TODO: This should move into the caller to decide whether giving up is valid.\n  if ((bumpedLane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n    // Give up trying to hydrate and fall back to client render.\n    return NoLane;\n  }\n  return bumpedLane;\n}\n\nexport function getBumpedLaneForHydrationByLane(lane: Lane): Lane {\n  switch (lane) {\n    case SyncLane:\n      lane = SyncHydrationLane;\n      break;\n    case InputContinuousLane:\n      lane = InputContinuousHydrationLane;\n      break;\n    case DefaultLane:\n      lane = DefaultHydrationLane;\n      break;\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n      lane = TransitionHydrationLane;\n      break;\n    case IdleLane:\n      lane = IdleHydrationLane;\n      break;\n    default:\n      // Everything else is already either a hydration lane, or shouldn't\n      // be retried at a hydration lane.\n      lane = NoLane;\n      break;\n  }\n  return lane;\n}\n\nexport function addFiberToLanesMap(\n  root: FiberRoot,\n  fiber: Fiber,\n  lanes: Lanes | Lane,\n) {\n  if (!enableUpdaterTracking) {\n    return;\n  }\n  if (!isDevToolsPresent) {\n    return;\n  }\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n\n    const updaters = pendingUpdatersLaneMap[index];\n    updaters.add(fiber);\n\n    lanes &= ~lane;\n  }\n}\n\nexport function movePendingFibersToMemoized(root: FiberRoot, lanes: Lanes) {\n  if (!enableUpdaterTracking) {\n    return;\n  }\n  if (!isDevToolsPresent) {\n    return;\n  }\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n  const memoizedUpdaters = root.memoizedUpdaters;\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n\n    const updaters = pendingUpdatersLaneMap[index];\n    if (updaters.size > 0) {\n      updaters.forEach(fiber => {\n        const alternate = fiber.alternate;\n        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n          memoizedUpdaters.add(fiber);\n        }\n      });\n      updaters.clear();\n    }\n\n    lanes &= ~lane;\n  }\n}\n\nexport function addTransitionToLanesMap(\n  root: FiberRoot,\n  transition: Transition,\n  lane: Lane,\n) {\n  if (enableTransitionTracing) {\n    const transitionLanesMap = root.transitionLanes;\n    const index = laneToIndex(lane);\n    let transitions = transitionLanesMap[index];\n    if (transitions === null) {\n      transitions = new Set();\n    }\n    transitions.add(transition);\n\n    transitionLanesMap[index] = transitions;\n  }\n}\n\nexport function getTransitionsForLanes(\n  root: FiberRoot,\n  lanes: Lane | Lanes,\n): Array<Transition> | null {\n  if (!enableTransitionTracing) {\n    return null;\n  }\n\n  const transitionsForLanes = [];\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n    const transitions = root.transitionLanes[index];\n    if (transitions !== null) {\n      transitions.forEach(transition => {\n        transitionsForLanes.push(transition);\n      });\n    }\n\n    lanes &= ~lane;\n  }\n\n  if (transitionsForLanes.length === 0) {\n    return null;\n  }\n\n  return transitionsForLanes;\n}\n\nexport function clearTransitionsForLanes(root: FiberRoot, lanes: Lane | Lanes) {\n  if (!enableTransitionTracing) {\n    return;\n  }\n\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n\n    const transitions = root.transitionLanes[index];\n    if (transitions !== null) {\n      root.transitionLanes[index] = null;\n    }\n\n    lanes &= ~lane;\n  }\n}\n\n// Used to name the Performance Track\nexport function getGroupNameOfHighestPriorityLane(lanes: Lanes): string {\n  if (\n    lanes &\n    (SyncHydrationLane |\n      SyncLane |\n      InputContinuousHydrationLane |\n      InputContinuousLane |\n      DefaultHydrationLane |\n      DefaultLane |\n      GestureLane)\n  ) {\n    return 'Blocking';\n  }\n  if (lanes & (TransitionHydrationLane | TransitionLanes)) {\n    return 'Transition';\n  }\n  if (lanes & RetryLanes) {\n    return 'Suspense';\n  }\n  if (\n    lanes &\n    (SelectiveHydrationLane |\n      IdleHydrationLane |\n      IdleLane |\n      OffscreenLane |\n      DeferredLane)\n  ) {\n    return 'Idle';\n  }\n  return 'Other';\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Lane, Lanes} from './ReactFiberLane';\n\nimport {\n  NoLane,\n  SyncLane,\n  InputContinuousLane,\n  DefaultLane,\n  IdleLane,\n  getHighestPriorityLane,\n  includesNonIdleWork,\n} from './ReactFiberLane';\n\nexport opaque type EventPriority = Lane;\n\nexport const NoEventPriority: EventPriority = NoLane;\nexport const DiscreteEventPriority: EventPriority = SyncLane;\nexport const ContinuousEventPriority: EventPriority = InputContinuousLane;\nexport const DefaultEventPriority: EventPriority = DefaultLane;\nexport const IdleEventPriority: EventPriority = IdleLane;\n\nexport function higherEventPriority(\n  a: EventPriority,\n  b: EventPriority,\n): EventPriority {\n  return a !== 0 && a < b ? a : b;\n}\n\nexport function lowerEventPriority(\n  a: EventPriority,\n  b: EventPriority,\n): EventPriority {\n  return a === 0 || a > b ? a : b;\n}\n\nexport function isHigherEventPriority(\n  a: EventPriority,\n  b: EventPriority,\n): boolean {\n  return a !== 0 && a < b;\n}\n\nexport function eventPriorityToLane(updatePriority: EventPriority): Lane {\n  return updatePriority;\n}\n\nexport function lanesToEventPriority(lanes: Lanes): EventPriority {\n  const lane = getHighestPriorityLane(lanes);\n  if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n    return DiscreteEventPriority;\n  }\n  if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n    return ContinuousEventPriority;\n  }\n  if (includesNonIdleWork(lane)) {\n    return DefaultEventPriority;\n  }\n  return IdleEventPriority;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport * as React from 'react';\n\nconst ReactSharedInternals =\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n\nexport default ReactSharedInternals;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {disableLegacyMode} from 'shared/ReactFeatureFlags';\nimport {DiscreteEventPriority} from 'react-reconciler/src/ReactEventPriorities';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nimport ReactDOMSharedInternals from 'shared/ReactDOMSharedInternals';\n\ndeclare function flushSyncImpl<R>(fn: () => R): R;\ndeclare function flushSyncImpl(void): void;\nfunction flushSyncImpl<R>(fn: (() => R) | void): R | void {\n  const previousTransition = ReactSharedInternals.T;\n  const previousUpdatePriority =\n    ReactDOMSharedInternals.p; /* ReactDOMCurrentUpdatePriority */\n\n  try {\n    ReactSharedInternals.T = null;\n    ReactDOMSharedInternals.p /* ReactDOMCurrentUpdatePriority */ =\n      DiscreteEventPriority;\n    if (fn) {\n      return fn();\n    } else {\n      return undefined;\n    }\n  } finally {\n    ReactSharedInternals.T = previousTransition;\n    ReactDOMSharedInternals.p /* ReactDOMCurrentUpdatePriority */ =\n      previousUpdatePriority;\n    const wasInRender =\n      ReactDOMSharedInternals.d /* ReactDOMCurrentDispatcher */\n        .f(); /* flushSyncWork */\n    if (__DEV__) {\n      if (wasInRender) {\n        console.error(\n          'flushSync was called from inside a lifecycle method. React cannot ' +\n            'flush when React is already rendering. Consider moving this call to ' +\n            'a scheduler task or micro task.',\n        );\n      }\n    }\n  }\n}\n\ndeclare function flushSyncErrorInBuildsThatSupportLegacyMode<R>(fn: () => R): R;\ndeclare function flushSyncErrorInBuildsThatSupportLegacyMode(void): void;\nfunction flushSyncErrorInBuildsThatSupportLegacyMode() {\n  // eslint-disable-next-line react-internal/prod-error-codes\n  throw new Error(\n    'Expected this build of React to not support legacy mode but it does. This is a bug in React.',\n  );\n}\n\nexport const flushSync: typeof flushSyncImpl = disableLegacyMode\n  ? flushSyncImpl\n  : flushSyncErrorInBuildsThatSupportLegacyMode;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport opaque type CrossOriginString: string = string;\n\nexport function getCrossOriginString(input: ?string): ?CrossOriginString {\n  if (typeof input === 'string') {\n    return input === 'use-credentials' ? input : '';\n  }\n  return undefined;\n}\n\nexport function getCrossOriginStringAs(\n  as: ?string,\n  input: ?string,\n): ?CrossOriginString {\n  if (as === 'font') {\n    return '';\n  }\n  if (typeof input === 'string') {\n    return input === 'use-credentials' ? input : '';\n  }\n  return undefined;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport type {\n  PreconnectOptions,\n  PreloadOptions,\n  PreloadModuleOptions,\n  PreinitOptions,\n  PreinitModuleOptions,\n} from './ReactDOMTypes';\n\nimport ReactDOMSharedInternals from 'shared/ReactDOMSharedInternals';\n\nimport {\n  getCrossOriginString,\n  getCrossOriginStringAs,\n} from 'react-dom-bindings/src/shared/crossOriginStrings';\n\nexport function prefetchDNS(href: string) {\n  if (__DEV__) {\n    if (typeof href !== 'string' || !href) {\n      console.error(\n        'ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.',\n        getValueDescriptorExpectingObjectForWarning(href),\n      );\n    } else if (arguments.length > 1) {\n      const options = arguments[1];\n      if (\n        typeof options === 'object' &&\n        options.hasOwnProperty('crossOrigin')\n      ) {\n        console.error(\n          'ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.',\n          getValueDescriptorExpectingEnumForWarning(options),\n        );\n      } else {\n        console.error(\n          'ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.',\n          getValueDescriptorExpectingEnumForWarning(options),\n        );\n      }\n    }\n  }\n  if (typeof href === 'string') {\n    ReactDOMSharedInternals.d /* ReactDOMCurrentDispatcher */\n      .D(/* prefetchDNS */ href);\n  }\n  // We don't error because preconnect needs to be resilient to being called in a variety of scopes\n  // and the runtime may not be capable of responding. The function is optimistic and not critical\n  // so we favor silent bailout over warning or erroring.\n}\n\nexport function preconnect(href: string, options?: ?PreconnectOptions) {\n  if (__DEV__) {\n    if (typeof href !== 'string' || !href) {\n      console.error(\n        'ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.',\n        getValueDescriptorExpectingObjectForWarning(href),\n      );\n    } else if (options != null && typeof options !== 'object') {\n      console.error(\n        'ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.',\n        getValueDescriptorExpectingEnumForWarning(options),\n      );\n    } else if (options != null && typeof options.crossOrigin !== 'string') {\n      console.error(\n        'ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.',\n        getValueDescriptorExpectingObjectForWarning(options.crossOrigin),\n      );\n    }\n  }\n  if (typeof href === 'string') {\n    const crossOrigin = options\n      ? getCrossOriginString(options.crossOrigin)\n      : null;\n    ReactDOMSharedInternals.d /* ReactDOMCurrentDispatcher */\n      .C(/* preconnect */ href, crossOrigin);\n  }\n  // We don't error because preconnect needs to be resilient to being called in a variety of scopes\n  // and the runtime may not be capable of responding. The function is optimistic and not critical\n  // so we favor silent bailout over warning or erroring.\n}\n\nexport function preload(href: string, options: PreloadOptions) {\n  if (__DEV__) {\n    let encountered = '';\n    if (typeof href !== 'string' || !href) {\n      encountered += ` The \\`href\\` argument encountered was ${getValueDescriptorExpectingObjectForWarning(\n        href,\n      )}.`;\n    }\n    if (options == null || typeof options !== 'object') {\n      encountered += ` The \\`options\\` argument encountered was ${getValueDescriptorExpectingObjectForWarning(\n        options,\n      )}.`;\n    } else if (typeof options.as !== 'string' || !options.as) {\n      encountered += ` The \\`as\\` option encountered was ${getValueDescriptorExpectingObjectForWarning(\n        options.as,\n      )}.`;\n    }\n    if (encountered) {\n      console.error(\n        'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel=\"preload\" as=\"...\" />` tag.%s',\n        encountered,\n      );\n    }\n  }\n  if (\n    typeof href === 'string' &&\n    // We check existence because we cannot enforce this function is actually called with the stated type\n    typeof options === 'object' &&\n    options !== null &&\n    typeof options.as === 'string'\n  ) {\n    const as = options.as;\n    const crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);\n    ReactDOMSharedInternals.d /* ReactDOMCurrentDispatcher */\n      .L(/* preload */ href, as, {\n        crossOrigin,\n        integrity:\n          typeof options.integrity === 'string' ? options.integrity : undefined,\n        nonce: typeof options.nonce === 'string' ? options.nonce : undefined,\n        type: typeof options.type === 'string' ? options.type : undefined,\n        fetchPriority:\n          typeof options.fetchPriority === 'string'\n            ? options.fetchPriority\n            : undefined,\n        referrerPolicy:\n          typeof options.referrerPolicy === 'string'\n            ? options.referrerPolicy\n            : undefined,\n        imageSrcSet:\n          typeof options.imageSrcSet === 'string'\n            ? options.imageSrcSet\n            : undefined,\n        imageSizes:\n          typeof options.imageSizes === 'string'\n            ? options.imageSizes\n            : undefined,\n        media: typeof options.media === 'string' ? options.media : undefined,\n      });\n  }\n  // We don't error because preload needs to be resilient to being called in a variety of scopes\n  // and the runtime may not be capable of responding. The function is optimistic and not critical\n  // so we favor silent bailout over warning or erroring.\n}\n\nexport function preloadModule(href: string, options?: ?PreloadModuleOptions) {\n  if (__DEV__) {\n    let encountered = '';\n    if (typeof href !== 'string' || !href) {\n      encountered += ` The \\`href\\` argument encountered was ${getValueDescriptorExpectingObjectForWarning(\n        href,\n      )}.`;\n    }\n    if (options !== undefined && typeof options !== 'object') {\n      encountered += ` The \\`options\\` argument encountered was ${getValueDescriptorExpectingObjectForWarning(\n        options,\n      )}.`;\n    } else if (options && 'as' in options && typeof options.as !== 'string') {\n      encountered += ` The \\`as\\` option encountered was ${getValueDescriptorExpectingObjectForWarning(\n        options.as,\n      )}.`;\n    }\n    if (encountered) {\n      console.error(\n        'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel=\"modulepreload\" as=\"...\" />` tag.%s',\n        encountered,\n      );\n    }\n  }\n  if (typeof href === 'string') {\n    if (options) {\n      const crossOrigin = getCrossOriginStringAs(\n        options.as,\n        options.crossOrigin,\n      );\n      ReactDOMSharedInternals.d /* ReactDOMCurrentDispatcher */\n        .m(/* preloadModule */ href, {\n          as:\n            typeof options.as === 'string' && options.as !== 'script'\n              ? options.as\n              : undefined,\n          crossOrigin,\n          integrity:\n            typeof options.integrity === 'string'\n              ? options.integrity\n              : undefined,\n        });\n    } else {\n      ReactDOMSharedInternals.d /* ReactDOMCurrentDispatcher */\n        .m(/* preloadModule */ href);\n    }\n  }\n  // We don't error because preload needs to be resilient to being called in a variety of scopes\n  // and the runtime may not be capable of responding. The function is optimistic and not critical\n  // so we favor silent bailout over warning or erroring.\n}\n\nexport function preinit(href: string, options: PreinitOptions) {\n  if (__DEV__) {\n    if (typeof href !== 'string' || !href) {\n      console.error(\n        'ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.',\n        getValueDescriptorExpectingObjectForWarning(href),\n      );\n    } else if (options == null || typeof options !== 'object') {\n      console.error(\n        'ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.',\n        getValueDescriptorExpectingEnumForWarning(options),\n      );\n    } else if (options.as !== 'style' && options.as !== 'script') {\n      console.error(\n        'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are \"style\" and \"script\".',\n        getValueDescriptorExpectingEnumForWarning(options.as),\n      );\n    }\n  }\n  if (typeof href === 'string' && options && typeof options.as === 'string') {\n    const as = options.as;\n    const crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);\n    const integrity =\n      typeof options.integrity === 'string' ? options.integrity : undefined;\n    const fetchPriority =\n      typeof options.fetchPriority === 'string'\n        ? options.fetchPriority\n        : undefined;\n    if (as === 'style') {\n      ReactDOMSharedInternals.d /* ReactDOMCurrentDispatcher */\n        .S(\n          /* preinitStyle */\n          href,\n          typeof options.precedence === 'string'\n            ? options.precedence\n            : undefined,\n          {\n            crossOrigin,\n            integrity,\n            fetchPriority,\n          },\n        );\n    } else if (as === 'script') {\n      ReactDOMSharedInternals.d /* ReactDOMCurrentDispatcher */\n        .X(/* preinitScript */ href, {\n          crossOrigin,\n          integrity,\n          fetchPriority,\n          nonce: typeof options.nonce === 'string' ? options.nonce : undefined,\n        });\n    }\n  }\n  // We don't error because preinit needs to be resilient to being called in a variety of scopes\n  // and the runtime may not be capable of responding. The function is optimistic and not critical\n  // so we favor silent bailout over warning or erroring.\n}\n\nexport function preinitModule(href: string, options?: ?PreinitModuleOptions) {\n  if (__DEV__) {\n    let encountered = '';\n    if (typeof href !== 'string' || !href) {\n      encountered += ` The \\`href\\` argument encountered was ${getValueDescriptorExpectingObjectForWarning(\n        href,\n      )}.`;\n    }\n    if (options !== undefined && typeof options !== 'object') {\n      encountered += ` The \\`options\\` argument encountered was ${getValueDescriptorExpectingObjectForWarning(\n        options,\n      )}.`;\n    } else if (options && 'as' in options && options.as !== 'script') {\n      encountered += ` The \\`as\\` option encountered was ${getValueDescriptorExpectingEnumForWarning(\n        options.as,\n      )}.`;\n    }\n    if (encountered) {\n      console.error(\n        'ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s',\n        encountered,\n      );\n    } else {\n      const as =\n        options && typeof options.as === 'string' ? options.as : 'script';\n      switch (as) {\n        case 'script': {\n          break;\n        }\n\n        // We have an invalid as type and need to warn\n        default: {\n          const typeOfAs = getValueDescriptorExpectingEnumForWarning(as);\n          console.error(\n            'ReactDOM.preinitModule(): Currently the only supported \"as\" type for this function is \"script\"' +\n              ' but received \"%s\" instead. This warning was generated for `href` \"%s\". In the future other' +\n              ' module types will be supported, aligning with the import-attributes proposal. Learn more here:' +\n              ' (https://github.com/tc39/proposal-import-attributes)',\n            typeOfAs,\n            href,\n          );\n        }\n      }\n    }\n  }\n  if (typeof href === 'string') {\n    if (typeof options === 'object' && options !== null) {\n      if (options.as == null || options.as === 'script') {\n        const crossOrigin = getCrossOriginStringAs(\n          options.as,\n          options.crossOrigin,\n        );\n        ReactDOMSharedInternals.d /* ReactDOMCurrentDispatcher */\n          .M(/* preinitModuleScript */ href, {\n            crossOrigin,\n            integrity:\n              typeof options.integrity === 'string'\n                ? options.integrity\n                : undefined,\n            nonce:\n              typeof options.nonce === 'string' ? options.nonce : undefined,\n          });\n      }\n    } else if (options == null) {\n      ReactDOMSharedInternals.d /* ReactDOMCurrentDispatcher */\n        .M(/* preinitModuleScript */ href);\n    }\n  }\n  // We don't error because preinit needs to be resilient to being called in a variety of scopes\n  // and the runtime may not be capable of responding. The function is optimistic and not critical\n  // so we favor silent bailout over warning or erroring.\n}\n\nfunction getValueDescriptorExpectingObjectForWarning(thing: any): string {\n  return thing === null\n    ? '`null`'\n    : thing === undefined\n      ? '`undefined`'\n      : thing === ''\n        ? 'an empty string'\n        : `something with type \"${typeof thing}\"`;\n}\n\nfunction getValueDescriptorExpectingEnumForWarning(thing: any): string {\n  return thing === null\n    ? '`null`'\n    : thing === undefined\n      ? '`undefined`'\n      : thing === ''\n        ? 'an empty string'\n        : typeof thing === 'string'\n          ? JSON.stringify(thing)\n          : typeof thing === 'number'\n            ? '`' + thing + '`'\n            : `something with type \"${typeof thing}\"`;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {Awaited} from 'shared/ReactTypes';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport ReactDOMSharedInternals from 'shared/ReactDOMSharedInternals';\n\ntype FormStatusNotPending = {|\n  pending: false,\n  data: null,\n  method: null,\n  action: null,\n|};\n\ntype FormStatusPending = {|\n  pending: true,\n  data: FormData,\n  method: string,\n  action: string | (FormData => void | Promise<void>) | null,\n|};\n\nexport type FormStatus = FormStatusPending | FormStatusNotPending;\n\n// Since the \"not pending\" value is always the same, we can reuse the\n// same object across all transitions.\nconst sharedNotPendingObject = {\n  pending: false,\n  data: null,\n  method: null,\n  action: null,\n};\n\nexport const NotPending: FormStatus = __DEV__\n  ? Object.freeze(sharedNotPendingObject)\n  : sharedNotPendingObject;\n\nfunction resolveDispatcher() {\n  // Copied from react/src/ReactHooks.js. It's the same thing but in a\n  // different package.\n  const dispatcher = ReactSharedInternals.H;\n  if (__DEV__) {\n    if (dispatcher === null) {\n      console.error(\n        'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n          ' one of the following reasons:\\n' +\n          '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n          '2. You might be breaking the Rules of Hooks\\n' +\n          '3. You might have more than one copy of React in the same app\\n' +\n          'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.',\n      );\n    }\n  }\n  // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n  return ((dispatcher: any): Dispatcher);\n}\n\nexport function useFormStatus(): FormStatus {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useHostTransitionStatus();\n}\n\nexport function useFormState<S, P>(\n  action: (Awaited<S>, P) => S,\n  initialState: Awaited<S>,\n  permalink?: string,\n): [Awaited<S>, (P) => void, boolean] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useFormState(action, initialState, permalink);\n}\n\nexport function requestFormReset(form: HTMLFormElement) {\n  ReactDOMSharedInternals.d /* ReactDOMCurrentDispatcher */\n    .r(/* requestFormReset */ form);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactNodeList} from 'shared/ReactTypes';\n\nimport ReactVersion from 'shared/ReactVersion';\n\nimport {isValidContainer} from 'react-dom-bindings/src/client/ReactDOMContainer';\nimport {createPortal as createPortalImpl} from 'react-reconciler/src/ReactPortal';\nimport {flushSync} from './ReactDOMFlushSync';\n\nimport {\n  prefetchDNS,\n  preconnect,\n  preload,\n  preloadModule,\n  preinit,\n  preinitModule,\n} from './ReactDOMFloat';\nimport {\n  requestFormReset,\n  useFormStatus,\n  useFormState,\n} from 'react-dom-bindings/src/shared/ReactDOMFormActions';\n\nif (__DEV__) {\n  if (\n    typeof Map !== 'function' ||\n    // $FlowFixMe[prop-missing] Flow incorrectly thinks Map has no prototype\n    Map.prototype == null ||\n    typeof Map.prototype.forEach !== 'function' ||\n    typeof Set !== 'function' ||\n    // $FlowFixMe[prop-missing] Flow incorrectly thinks Set has no prototype\n    Set.prototype == null ||\n    typeof Set.prototype.clear !== 'function' ||\n    typeof Set.prototype.forEach !== 'function'\n  ) {\n    console.error(\n      'React depends on Map and Set built-in types. Make sure that you load a ' +\n        'polyfill in older browsers. https://reactjs.org/link/react-polyfills',\n    );\n  }\n}\n\nfunction batchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\n  // batchedUpdates is now just a passthrough noop\n  return fn(a);\n}\n\nfunction createPortal(\n  children: ReactNodeList,\n  container: Element | DocumentFragment,\n  key: ?string = null,\n): React$Portal {\n  if (!isValidContainer(container)) {\n    throw new Error('Target container is not a DOM element.');\n  }\n\n  // TODO: pass ReactDOM portal implementation as third argument\n  // $FlowFixMe[incompatible-return] The Flow type is opaque but there's no way to actually create it.\n  return createPortalImpl(children, container, null, key);\n}\n\nexport {\n  ReactVersion as version,\n  createPortal,\n  flushSync,\n  batchedUpdates as unstable_batchedUpdates,\n  prefetchDNS,\n  preconnect,\n  preload,\n  preloadModule,\n  preinit,\n  preinitModule,\n  requestFormReset,\n  useFormStatus,\n  useFormState,\n};\n"],"names":["NoEventPriority","noop","requestFormReset","element","Error","DefaultDispatcher","f","r","D","C","L","m","X","S","M","Internals","d","p","findDOMNode","disableCommentsAsDOMContainers","ELEMENT_NODE","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","isValidContainer","node","nodeType","REACT_PORTAL_TYPE","Symbol","for","typeName","value","hasToStringTag","toStringTag","type","constructor","name","willCoercionThrow","testStringCoercion","e","checkKeyStringCoercion","console","error","createPortal","children","containerInfo","implementation","key","arguments","length","undefined","$$typeof","SyncLane","DiscreteEventPriority","ReactSharedInternals","React","__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","flushSyncImpl","fn","previousTransition","T","previousUpdatePriority","ReactDOMSharedInternals","wasInRender","flushSync","getCrossOriginString","input","getCrossOriginStringAs","as","prefetchDNS","href","getValueDescriptorExpectingObjectForWarning","options","hasOwnProperty","getValueDescriptorExpectingEnumForWarning","preconnect","crossOrigin","preload","encountered","integrity","nonce","fetchPriority","referrerPolicy","imageSrcSet","imageSizes","media","preloadModule","preinit","precedence","preinitModule","typeOfAs","thing","JSON","stringify","resolveDispatcher","dispatcher","H","useFormStatus","useHostTransitionStatus","useFormState","action","initialState","permalink","form","Map","prototype","forEach","Set","clear","batchedUpdates","a","container","createPortalImpl"],"mappings":"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"}